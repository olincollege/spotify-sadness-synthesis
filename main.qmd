---
jupyter: python3
---

```{python}
%load_ext autoreload
%autoreload 2
```

```{python}
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
```

Fetch data from the api.

```{python}
import data_collector
data_collector.login()
mitski_all = data_collector.get_all_playlists("mitski.txt")
phoebe_all = data_collector.get_all_playlists("phoebe.txt")
```

Then, we use the spearman correlation coefficient to compare the rankings of songs in each playlist with a "model" normal order and reverse order playlist. We decided these model playlists based on the number of likes (indicated that the ranking was fairly agreed upon), the number of songs in the playlist (if the playlist has all of the songs it can be more accurately compared to other playlists), and clear indication of which way the playlist was ordered. 

```{python}
import data_helpers
ambiguous_indexes, reversed_indexes = data_helpers.find_anomalies(mitski_all, 0, 2)
print(ambiguous_indexes)
print(reversed_indexes)
```

This returns a list of which indexes are ambiguous, meaning the combined correlation with both direction of playlists is less than 0.5. Looking at these 3 playlists, one has only a small subsection of Mitski's music, one includes non-Mitski music, and one at glance has a somewhat atypical ranking. 

The second list is the playlists that are in reversed order (least sad at the top), determined by the fact that they have a negative correlation with the normal order playlist and a positive correlation with reverse order playlist. 

```{python}
mitski_temp = mitski_all
phoebe_temp = phoebe_all
```

```{python}
import data_helpers
ambiguous_indexes, reversed_indexes = data_helpers.find_anomalies(mitski_all, 0, 2)
```

```{python}
import pandas as pd
mitski_df = pd.DataFrame(mitski_all)

for i in reversed_indexes:
    mitski_all[i] = list(reversed(mitski_df.loc[i].dropna()))

for idx, element in enumerate(ambiguous_indexes):
    mitski_all.pop(element- idx) # bcs indexes get moved when something is popped

mitski_df = pd.DataFrame(mitski_all)
mitski_df
```

This process is repeated with the Phoebe Bridgers playlists. 

```{python}
ambiguous_indexes, reversed_indexes = data_helpers.find_anomalies(phoebe_all, 6, 2)
print(ambiguous_indexes)
print(reversed_indexes)
```

We discovered a high normal of playlists marked at "ambiguous". This is likely due to the fact that Phoebe has more songs, and so many songs include a much more limited portion of her music. In addition, Phoebe has a lot of music she creates with other artists, and some playlists include this while others do not. 
Therefore, we reran with a more specific threshold for ambiguity of 0.2. 

```{python}
ambiguous_indexes, reversed_indexes = data_helpers.find_anomalies(phoebe_all, 6, 2, 0.2)
print(ambiguous_indexes)
print(reversed_indexes)
```

```{python}
import pandas as pd
phoebe_df = pd.DataFrame(mitski_all)

phoebe_all = data_helpers.reverse_rows(phoebe_all, reversed_indexes)

for idx, element in enumerate(ambiguous_indexes):
    phoebe_all.pop(element- idx) # bcs indexes get moved when something is popped

phoebe_df = pd.DataFrame(phoebe_all)
phoebe_df
```

```{python}
mitski_df.to_csv("mitski_data.csv")
phoebe_df.to_csv("phoebe_data.csv")
```

```{python}
from data_helpers import *
from annotations import *
from data_collector import *

# mitski_rank = get_avg_ranking(mitski_df)
# graph_songs_percentile(mitski_rank, "Mitski Percentiles", 30)

# phoebe_rank = get_avg_ranking(phoebe_df)
# graph_songs_percentile(phoebe_rank, "Phoebe Percentiles", 30)

# print(len(mitski_rank))
mitski_all = get_all_ranking(mitski_df)
print(find_least_controversial(mitski_all, 10))
lh, btc, p2, bmamc, rfsncib, lush, sita, punisher, boygenius = get_all_albums()

mitski_rank = get_avg_ranking(mitski_df)
```

```{python}
from annotations import *
from itertools import islice


phoebe_rank_boxplot = get_all_ranking(phoebe_df, 5)
 


keys, values = zip(*phoebe_rank_boxplot.items())
half = len(phoebe_rank_boxplot)//2
res1 = dict(zip(keys[:half], values[:half]))
res2 = dict(zip(keys[half:], values[half:]))

# make_boxplot_songs(phoebe_rank_boxplot, "All Phoebe Songs", )

bmamc1 = make_dict_one_album(bmamc, mitski_all)

make_boxplot_songs(bmamc1, "Puberty 2")

graph_songs_percentile(mitski_rank, "mitski")
```

```{python}
p2_songs = [*puberty2.keys()]
print(create_box_colors(p2_songs))
```

